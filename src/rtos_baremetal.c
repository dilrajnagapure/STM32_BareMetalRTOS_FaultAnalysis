/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "stdio.h"
#include "stdint.h"

extern initialise_monitor_handles();

void task1_handler(void);
void task2_handler(void);
void task3_handler(void);
void task4_handler(void);

#define SIZE_TASK_STACK       1024U
#define SRAM_SIZE             ((96) * (1024))
#define SRAM_START            0x20000000U
#define SRAM_END              ((SRAM_START) + (SRAM_SIZE))
#define TASK1_STACK_START     SRAM_END
#define TASK2_STACK_START     ((SRAM_END) - (1 * SIZE_TASK_STACK))
#define TASK3_STACK_START     ((SRAM_END) - (2 * SIZE_TASK_STACK))
#define TASK4_STACK_START     ((SRAM_END) - (3 * SIZE_TASK_STACK))
#define SCHED_STACK_START     ((SRAM_END) - (4 * SIZE_TASK_STACK))

#define HSI_CLK              16000000U
#define SYSTICK_TIM_CLK      HSI_CLK
#define TICK_HZ              1000U

#define MAX_TASKS            4

#define DUMMY_XPSR           0x01000000 //thumb bit

void init_systick_timer(uint32_t tick_hz);
__attribute__ ((naked)) void  init_scheduler(uint32_t sched_top_of_stack);
void init_task_stacks(void);
void enable_processor_fault(void);
uint32_t get_psp_value(void);
__attribute ((naked)) void switch_to_psp(void);

uint32_t psp_of_stack[MAX_TASKS] = { TASK1_STACK_START,TASK2_STACK_START, TASK3_STACK_START,TASK4_STACK_START };
uint32_t task_handlers[MAX_TASKS];
uint8_t current_task =0;//task1 is running

int main(void)
{
    /* Loop forever */
	enable_processor_fault();

	initialise_monitor_handles();

	init_scheduler(SCHED_STACK_START);

	task_handlers[0] = (uint32_t)task1_handler;
	task_handlers[1] = (uint32_t)task2_handler;
	task_handlers[2] = (uint32_t)task3_handler;
	task_handlers[3] = (uint32_t)task4_handler;

	init_task_stacks();

	switch_to_psp();

	init_systick_timer( TICK_HZ );

	task1_handler();

	for(;;);
}

uint32_t get_psp_value(void)
{
	return psp_of_stack[current_task];
}
__attribute ((naked)) void switch_to_psp(void)
{
	//1. Initialize the PSP with Task1 stack start address

	//get the PSP value of tasks
	__asm volatile ("PUSH {LR}");// preserve LR because following instruction corrupts LR
	__asm volatile ("BL get_psp_value");//branch with link to get back to called function
	__asm volatile ("MSR PSP,R0");//by arm cortex standard R0 will have return value
	__asm volatile ("POP {LR}");// pop back main LR

	//2. Change the SP to PSP using CONTROL register
	__asm volatile ("MOV R0,#0x02");
	__asm volatile ("MSR CONTROL,R0");
	__asm volatile ("BX LR");

}

//intializing tasks stacks for each stack, creating dummy stack if any of the task is running for the first time
void init_task_stacks(void)
{
	uint32_t *pPSP;
	for ( int i =0;i<MAX_TASKS;i++)
	{
		pPSP = (uint32_t *)psp_of_stack[i];

		pPSP--;//XPSR
		*pPSP = DUMMY_XPSR;//first value should be XPSP = 0x01000000;

		pPSP--;//PC
		*pPSP = task_handlers[i];

		pPSP--;//LR
		*pPSP = 0xFFFFFFFD;//return to thread mode and use PSP

		//update register R0-R13 with 0
		for(int  j =0;j<13;j++)
		{
			pPSP--;
			*pPSP = 0;
		}

		//preserve the PSP of tasks
		psp_of_stack[i] = (uint32_t )pPSP;
	}
}

void init_systick_timer(uint32_t tick_hz)
{
	uint32_t * pSRVR = (uint32_t *)0xE000E014;
	uint32_t * pSCSR = (uint32_t *)0xE000E010;

	uint32_t count_value = (SYSTICK_TIM_CLK/tick_hz)-1;

	//Clear the value of SVR
	*pSRVR &= ~(0x00FFFFFF);

	//laod the value into SVR
	*pSRVR |= count_value;

	//do settings
	*pSCSR |= ( 1 << 1 ); //Enable sysytick exception request
	*pSCSR |= ( 1 << 2 ); //Indicates the clock source . processor clock source

	//enable the systick
	*pSCSR |= ( 1 << 0 ); //enables the counter

}

__attribute__ ((naked)) void  init_scheduler(uint32_t sched_top_of_stack)
{
	__asm volatile ("MSR MSP,%0": : "r"(sched_top_of_stack) : );
	__asm volatile ("BX LR");
}
void SysTick_Handler(void)
{

}
void MemManage_Handler(void)
{
	while(1);
}

void task1_handler(void)
{
	while(1)
	{
		printf("Task-1 is running");
	}
}
void task2_handler(void)
{
	while(1)
	{
		printf("Task-2 is running");
	}
}
void task3_handler(void)
{
	while(1)
	{
		printf("Task-3 is running");
	}
}
void task4_handler(void)
{
	while(1)
	{
		printf("Task-4 is running");
	}
}


void enable_processor_fault(void)
{
	//System Handler Control and State Register
	uint32_t *pSHCRS = (uint32_t *)0xE000ED24;

	//enable MEMFAULT
	*pSHCRS = ( 1 << 16 );

	//enable BUSFAULT
	*pSHCRS = ( 1 << 17 );

	//enable USAGEFAULT
	*pSHCRS = ( 1 << 18 );

}
void BusFault_Handler(void)
{
	while(1);
}
__attribute__ ((naked)) void UsageFault_Handler(void)
{
	__asm ("MRS r0,MSP");
	__asm ("B UsageFault_Handler_c");
}
void UsageFault_Handler_c(uint32_t * pBaseStackFrame)
{
	printf("MSP = %p\n",pBaseStackFrame);
	printf("Value of R0 = %lx\n", pBaseStackFrame[0]);
	printf("Value of R1 = %lx\n", pBaseStackFrame[1]);
	printf("Value of R2 = %lx\n", pBaseStackFrame[2]);
	printf("Value of R3 = %lx\n", pBaseStackFrame[3]);
	printf("Value of R12 = %lx\n", pBaseStackFrame[4]);
	printf("Value of LR = %lx\n", pBaseStackFrame[5]);
	printf("Value of PC = %lx\n", pBaseStackFrame[6]);
	printf("Value of XPSR = %lx\n", pBaseStackFrame[7]);
	while(1);
}

void HardFault_Handler(void)
{
	while(1);
}
